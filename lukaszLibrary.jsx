///////////////////////////////////////////  DEBUGZ THA C0DEZ, mang.////////////////////////////////////// print object properties/methods function printObj(obj) {    var key;    $.write("----------\n");    $.write("keys: \n\n");        for(key in obj) {                $.write(key + " : " + obj[key].toString() +'\n');         }    $.write("----------\n");};//write to consolefunction print(i) {    if(i == "object"){         print("you are trying to printObject, use printObj(); function");     }    else {          $.write(i+"\n");     }};function printType(input) {    $.write(typeof input);}function isObject(myInput) {    return typeof myInput === 'object' && !myInput.length;}function isArray(obj) {    return Object.prototype.toString.call(obj) === '[object Array]';}////////////////////////////////////////// tools////////////////////////////////////////Number.prototype.roundTo = function(to) {    return Math.round(this * to) / to;}function roundTo(number, to) {    return Math.round(number * to) / to;}// find all items with name:Array.prototype.indexOf = Array.prototype.indexOf || function(value, start) {  for (var i = 0, length = this.length; i < length; i++) {    if (this[i] == value) {      return i;    }  }  return -1;}// extending ES for indexOfArray.prototype.each = function(callback) {  for (var i = 0, length = this.length; i < length; i++) {    callback(this[i], i);  }};Array.prototype.indexOf = Array.prototype.indexOf || function(value, start) {  for (var i = 0, length = this.length; i < length; i++) {    if (this[i] == value) {      return i;    }  }  return -1;}//just for funfunction type(o){    return !!o && Object.prototype.toString.call(o).match(/(\w+)\]/)[1];}    //set up array for each itemToLoop    /*     var itemNames = [];        for( i = 0; i < itemsToLoop.length; i++) {        var itemName[i] = itemsToLoop[i].name;        // push layer/symbol/path name to correct key name        itemNames.push(itemName[i]);    }    *///create class with all things we would ever want to loop through layers, symbolItems, pathItems.// already a class for this look up: pageItemsfunction documentItems() {       var doc = app.activeDocument;    // list of items we might want to loop through    var itemsToLoop = [doc.layers, doc.symbolItems];    //reference for method to know how many layers, pathitems, symbols etc are being looped    //can I do: this.itemsToLoop = [doc.layers, doc.symbolItems]; to remove prev var?    this.itemsToLoop = [doc.layers, doc.symbolItems];};documentItems.prototype.findAndReplace = function(find, replace) {    var findTextInSymbolName = prompt("Text to find", find);    var replaceTextInSymbolName = prompt("Text to replace", replace);    for( i = 0; i < this.itemsToLoop[i].length; i++){        for( i = 0; i < this.itemName[i].length; i++){            // find and replace, if no matches then it just continues with no changes,             // built into replace method.            var currentItemName = itemToLoop[i].name;            currentItemName.replace(findTextInSymbolName, replaceTextInSymbolName);         }    }};function SymbolName() {    this.name = doc.symbolItems;};SymbolName.prototype.findAndReplace = function(find, replace) {      var findTextInSymbolName = prompt("Text to find", this.find);      var replaceTextInSymbolName = prompt("Text to replace", this.replace);          for( i = 0; i < this.itemsToLoop[i].length; i++){        for( i = 0; i < this.itemName[i].length; i++){            // find and replace, if no matches then it just continues with no changes,             // built into replace method.            var currentItemName = itemToLoop[i].name;            currentItemName.replace(findTextInSymbolName, replaceTextInSymbolName);         }    }  };////////////////////////////////////////// get an array of items with name//////////////////////////////////////////accepts string in first and top level layer in second as parentfunction getArrayOfItemsWithNameUnder(stringToMatch, parentItemToMatchUnder){    var doc = app.activeDocument,        layers = doc.layers,        arrayOfMatchedItems = [];            for(var i = 0; i < parentItemToMatchUnder.length; i++){        // grabs parent, else searches layers        var currentItemToSearch = parentItemToMatchUnder[i];        if (currentItemToSearch.name.indexOf(stringToMatch.toLowerCase()) != -1){            arrayOfMatchedItems.push(currentItemToSearch);        }    }    return arrayOfMatchedItems;}//////////////////////////////////////////////////////////////////////////////////// get children of a pseudo parent//////////////////////////////////////////////////////////////////////////////////// check if page item under a physical layer has childrenfunction checkIfPseudoParentHasChildren(peudoParentPageItem){    for(var i = 0; i < peudoParentPageItem.parent.pageItems.length; i++){        var currentPageItemUnderPhysicalLayer = physicalParentLayer.pageItems[i];        checkSinglePseudoParentPageItemForChildren(pageItemsUnderPhysicalLayer);     }}// check sudo-parent for children, sudo-parent is a pageItem in a layer, don't have physical childrent//this only checks one layer for children loopAllPageItemsUnderThisLayer() loops through all layers and calls this funcfunction checkSinglePseudoParentPageItemForChildren(pseudoParent) {    // PARENT LOOP    for(var i = 0; i < pseudoParent.parent.length; i++){ //checks the Parent layer, pseudo parent is actually a pageItem on same hierarchy level as rest of page items        print("#################"+childContainer.name+" : CHILD compare ###################");        var potentialParent = pseudoParent[i],            portentialParentArea = potentialParent[i].width*potentialParent[i].height;        // CHILD LOOP        for(var j = 0; j < subLayers.length; j++){            var potentialChild = pseudoParent.parent.pageItems[j], // checks input pseudo parent, gets its parent (Physical Parent Layer) and then goes back down to the page items                portentialChildArea = potentialChild[j].width*potentialChild[j].height;            if (i != j && usedContainerIndexes.indexOf(j) === -1){ //avoid references to self and duplicates                print("-----"+parentContainer.name+" : PARENT compair -----");                 if(isIn(potentialChild, potentialParent) &&  portentialChildArea < portentialParentArea) {                    print(potentialParent+" is a parent of: "+potentialChild);                }            }           }       }}////////////////////////////////////////// perform action on a layer// ****only works on top-most layers // doActionOnLayer("note", testFunction);//////////////////////////////////////////accepts layername as string and function name should not havefunction doActionOnLayer(layerName, functionName) {    for (var i = 0; i < numberOfLayers; i++) {         var customName = layerName; //layerName should be string        var myLayer = app.activeDocument.layers[i];        var myLayer = myLayer.name;        alert(myLayer);        if (customName == myLayer) {            var myLayerIndex = i;            alert(myLayerIndex);            functionName(myLayerIndex);            return myLayerIndex;        }    }};////////////////////////////////////////// get index name by layer name// ****only works on top-most layers ////////////////////////////////////////function getIndexByName(layerName) {    for (var i = 0; i < numberOfLayers; i++) {         var customName = layerName; //layerName should be string        var myLayer = app.activeDocument.layers[i].name;        if (customName == myLayer) {            return i;        }    }};////////////////////////////////////////// get layer name by index// ****only works on top-most layers ////////////////////////////////////////function getLayerNameByIndex(layerIndex) {     var layer = app.activeDocument.layers[layerIndex];    layer.visible = true;    var layerName = layer.name;    // Replace weird charecters in layer names    var layerName = layerName.replace(/\_-+/g,'-'); // Collapse multiple dashes into a single one     var layerName = layerName.replace(/\W+/g,'-');  // Replace Non-word characters    var layerName = layerName.replace(/^[-]+/, ''); // Remove forward dash    var layerName = layerName.replace(/[-]+$/, '');  // Remove trailing dash    return layerName; };//////////////////////////////////////// Return type of variable////////////////////////////////////function typeOf(input){ alert(typeof input); };//////////////////////////////////////// Layer by name////////////////////////////////////function layerName(index, input){    var myLayer = app.activeDocument.layers[input];    var myLayer = myLayer.name;};//////////////////////////////////////// loop groups by layer name////////////////////////////////////// use case /*function me() {    alert(itemName);}var itemName;loopPathItemsByLayer("parent", me);*///loop through all the page Items in a layer and runs function on each layerfunction findLayerAndExecute(layerName, functionName) { // layername accepts string, function name accepts function i.e. if you have function named runMe() then pass runMe    var pageItems = doc.layers.getByName(layerName).pageItems;    for ( var i = 0; i < pageItems.length; i++ ) {              print(grps.length);              var currentItem = pageItems[i];              var itemName = currentItem.name;              doc.selection = null;              pageItems[i].selected = true;              app.redraw();              functionName();    }};//////////////////////////////////////// match input color////////////////////////////////////function matchColor(r, g, b, inputColor) {        var matchMyRGB = new RGBColor();        matchMyRGB.red = r;        matchMyRGB.red = g;        matchMyRGB.red = b;        doActionOnLayers();        if(inputColor == matchMyRGB) {            return true;        }};//////////////////////////////////////// run action on top level layers//////////////////////////////////////input based on indexfunction doActionOnLayers(input) {    var myLayer = doc.layers[input];    for (var i = 0; i < myLayers; i++){        input();    }};//////////////////////////////////////// get object width and height//////////////////////////////////////input based on indexfunction getItemWidthHeightName(input) {    var myLayer = doc.layers[input];    var divNumber = myLayer.pathItems.length;    for (var i = 0; i < divNumber; i++){        var itemWidth = doc.pathItems[i].width;        var itemHeight = doc.pathItems[i].height;        var itemName = doc.pathItems[i].name;        divHeightWidth.push(itemName, itemWidth, itemHeight);          }    return divHeightWidth;};//************************////////////////////////////write CSV///////////////////////////*function CSV(how, exportObjectSize, docName){        this.how = how;                     // append is default        this.exportSize = exportObjectSize; // yes/no        this.docName = docName;             // file name to export to } CSV.prototype.export = function(input) {    var inputFolder = Folder.selectDialog();    var csv = new File(inputFolder+"/"+this.docName+".csv");          // open text again          switch(this.how) {            case "overwrite": csv.open("w"); break; //overwrite last setting            case "append": csv.open("a"); break; //append to file            default: csv.open("a");// set default to append to file          }          csv.writeln(input); // write your new data to it          csv.close(); // close csv}*/function CSVFile(fileName) {    this.fileName = fileName;};CSVFile.prototype.getFilePath = function() {    return inputFolder + "/" + this.fileName + ".csv";};CSVFile.prototype.write = function(input, mode) {        myCsv = new File(this.getFilePath());        myCsv.open(mode || "w"); // defaulted to write to file, also allows append        myCsv.writeln(input); // write your new data to it        myCsv.close(); // close csv};CSVFile.prototype.append = function(input) {    this.write(input, "a"); // append to file};CSVFile.prototype.edit = function(input) {   this.edit (input, "e"); //open in edit mode   tabellaDoc.open("e");// open in edit mode   tabellaDoc.seek(0, 2); // go to end of file   var stringa = activeDocument.name + " , " + dataFormattata + " , ";    tabellaDoc.writeln(input);    tabellaDoc.close(); };////////////////////////////////////////////////////// get the date last modified////////////////////////////////////////////////////function getModDate() {    if (filePath.created != null) {                        var creatDate = filePath.created.toString().split(' ');                        var creatDate = creatDate[1] + ' ' + creatDate[2] + ' ' + creatDate[3];                        frameC.contents = creatDate;    }}function getTodaysDate() {    var today = new Date(),        dd = today.getDate();    if (dd < 10) {dd ='0' + dd};        mm = today.getMonth() + 1;    if (mm < 10) {mm ='0' + mm};    var yyyy = today.getFullYear(),        heure=today.getHours() + ":" + today.getMinutes(),        thisDate = dd + '/' + mm + '/' + yyyy + "  " + heure;    return thisDate;}////////////////////////////////////////////////////// get collection of all text items////////////////////////////////////////////////////function getAllTextItems(){    var doc = app.activeDocument,        textProperties = [];    for(var i = 0; i < doc.textFrames.length; i++){        var left = Math.round(doc.textFrames[i].anchor[0]),            top = Math.round(doc.textFrames[i].anchor[1]),            font = doc.textFrames[i].textRange.characterAttributes.textFont.name,            style = doc.textFrames[i].textRange.characterAttributes.textFont,            alignment = doc.textFrames[i].textRange.characterAttributes.alignment,            fontSize = alignment = doc.textFrames[i].textRange.characterAttributes.size,            contents = doc.textFrames[i].contents;            //CSV.append(["null","null","text parent",top, left, contents, "text", "null", fontSize, alignment,font, style,"date time\n"]);    }    return textProperties;}////////////////////////////////////////////////////// crop artboard to visible bounds// fix to get around fact artboard wont crop to symbols////////////////////////////////////////////////////function cropArtboardToItem() {    var doc = app.activeDocument;    var docVB = doc.visibleBounds;    var left = docVB[0];    var top = docVB[1];    var right = docVB[2];    var bottom = docVB[3];    var ab = doc.artboards.getActiveArtboardIndex();    doc.artboards[ab].artboardRect = [left,top,right,bottom];};//////////////////////////// breakLinkToSymbols//////////////////////////function breakAllSymbols(){     var doc = app.activeDocument;     var SLen=doc.symbols.length-1;     for (i=SLen;i>-1;i--){         var symbolName = doc.symbols[i].name         doc.symbols[i].duplicate(doc, ElementPlacement.PLACEATBEGINNING);         doc.symbols[i].remove();         doc.symbols[i].name = symbolName     }     return true;};////////////////////save as PNG24//////////////////function exportFileToPNG24(name) {    if ( app.documents.length > 0 ) {        if (dest == undefined){            // !!! define dest outside of function so it doesn't ask for folder over and over            dest = Folder.selectDialog();            }        var exportOptions = new ExportOptionsPNG24();        var type = ExportType.PNG24;        var fileSpec = new File(dest+"/"+name);        exportOptions.antiAliasing = false;        exportOptions.transparency = true;        app.activeDocument.exportFile( fileSpec, type, exportOptions );    }};//////////////////////////// Get Item WidthHeight//////////////////////////function getItemWidthHeightName(input) {    var myLayer = doc.layers[input];    var divNumber = myLayer.pathItems.length;    for (var i = 0; i < divNumber; i++){        var itemWidth = doc.pathItems[i].width;        var itemHeight = doc.pathItems[i].height;        var itemName = doc.pathItems[i].name;        divHeightWidth.push(itemName, itemWidth, itemHeight);          }    return divHeightWidth;};// --------------------//////////////////////////// web save file format//////////////////////////function makeWebsafe(input){    //var output = [];    /*if(isArray(input)){        for(var i=0; i < input.length; i++){            input[i].replace(/\-+/g,'-');  // Collapse multiple dashes into a single one             output.push(input[i].replace(/\W+/g,'-')); // Replace Non-word characters        }     }    else { */        var output  = input.replace(/\-+/g,'-');        var output  = input.replace(/\W+/g,'-');      //}    return output;}//************************//////////////////////////// Export Symbol As PNG//////////////////////////function exportSymbolasPNG(){    /*if (!doc.symbolItems[6].visible) {        doc.symbolItems[2].visible = true;        alert("not visible");        }*/    var value = 0;    var win = new Window("palette{text:'We are bam wammin some kazam...hold on to those breeches',bounds:[100,100,550,140]," +                  "progress:Progressbar{bounds:[20,10,430,28] , minvalue:0,value:" + value + "}" +                  "};" );    win.progress.maxvalue = iCount;    for(var i = 0; i < iCount; i++) {        var symbolDocRef = doc;        var symbolRef = doc.symbolItems[i];        var newDoc = app.documents.add();        var newDocLayer = newDoc.layers.add();        symbolRef.duplicate(newDoc, ElementPlacement.PLACEATEND);        cropArtboardToItem();        //alert(dest);        exportFileToPNG24(symbolRef.symbol.name);        newDoc.close(SaveOptions.DONOTSAVECHANGES);        updateProgressBar(win);    }}    //////////////////    // progressBar    //////////////////    //!! must be inside of a loop    function updateProgressBar(win) {            win.center();            win.show();            win.progress.value++;            //update the window            win.layout.layout(true);    }function SymbolLibrary() {    this.all = this.doc.symbols;};////////////////////////////////////   test for float//////////////////////////////////function testForFloat(myArray) {    for( var i in myArray) {                if(key % 1 === 0) {            alert(myArray[i]+ "is not a float");        }    }};////////////////////////////////////   layers class///////////////////////////////////*function MyLayer(input) {    this.doc = app.activeDocument;    if(typeof input === "string") {        this.myLayerItem = this.doc.layers.getByName(input);        print('layer type stinrg');    }    else {        print('layer type not stinrg');        this.myLayerIndex = input || 0;         this.myLayerItem = this.hasLayerIndex() ? this.doc.layers[this.myLayerIndex] : false;    }    this.subLayers = this.myLayerItem.pageItems;    this.width = this.myLayerItem.width;    this.height = this.myLayerItem.height;}; */function MyLayer(input) {    this.doc = app.activeDocument;    this.myLayerIndex = input || 0;     this.myLayerItem = this.hasLayerIndex() ? this.doc.layers[this.myLayerIndex] : false;    this.subLayers = this.myLayerItem.pageItems;    this.width = this.myLayerItem.width;    this.height = this.myLayerItem.height;};MyLayer.prototype.hasLayerIndex = function() {    return this.myLayerIndex <= this.doc.layers.length - 1;};MyLayer.prototype.isIn = function(parentItem) {    var isTrue,        parentVB = parentItem.visibleBounds;     if ( this.left >= parentVB[0] && this.top >= parentVB[1] && this.right <= parentVB[2] && this.bottom >= parentVB[3]) {        isTrue = true;    } else {        isTrue = false;    }    if (isTrue){ return true; } };////////////////////////////////////   mySymbol class//////////////////////////////////function rotate90(input){ input.unshift(input.pop()); } //shift array one to right so it follows CSS style borders//accepts layer name or indexfunction MySymbol(input){    this.doc = app.activeDocument;    this.mySymbolIndex = input || 0;     this.mySymbolItem = this.hasSymbolIndex() ? this.doc.symbolItems[this.mySymbolIndex] : false;    this.visibleBounds = this.mySymbolItem.visibleBounds;    this.controlBounds = this.mySymbolItem.controlBounds;     // array of 4 numbers for position of bounding box     this.name = this.mySymbolItem.symbol.name;    this.top = Math.abs(this.mySymbolItem.top);    this.left = this.mySymbolItem.left;    this.topLeft = [Math.abs(this.mySymbolItem.top), this.mySymbolItem.left];} MySymbol.prototype.getPosition = function(top, left) {    //if(topLeft) {    var relativePositionTop = this.top - top;    var relativePositionLeft= this.left - left;    return [relativePositionTop, relativePositionLeft];    //} else { return [this.top, this.left]; }};MySymbol.prototype.hasSymbolIndex = function() {    return this.mySymbolIndex <= this.doc.symbolItems.length - 1;};MySymbol.prototype.getWidth = function() {    return this.mySymbolItem ? Math.round(this.mySymbolItem.width) : 0;};MySymbol.prototype.getHeight = function() {    return this.mySymbolItem ? Math.round(this.mySymbolItem.height) : 0;};// returns width and height as an arrayMySymbol.prototype.getWidthHeight = function() {     return [this.getWidth(), this.getHeight()];}MySymbol.prototype.isIn = function(parentItem) {    var isTrue,        child = this.visibleBounds,        parentVB = parentItem.visibleBounds,        parentLeft = parentVB[0], parentTop = Math.abs(parentVB[1]), parentRight = parentVB[2], parentBottom = Math.abs(parentVB[3]);            //print("parent is : " + parentItem.name);    //print("child is : " + this.name);    pointIsIn(parentLeft, parentTop, parentBottom, parentRight, child);    function pointIsIn(parentLeft, parentTop, parentBottom, parentRight, child) {         //print(parentItem.name+" bounds: "+parentLeft+" "+parentTop+" "+parentRight+" "+parentBottom);    //print("symbol bounds: "+ child[0] +" "+ Math.abs(child[1]) +" "+ child[2] +" "+ Math.abs(child[3]));                       if ( child[0] >= parentLeft && Math.abs(child[1]) >= parentTop && child[2] <= parentRight && Math.abs(child[3]) <= parentBottom) {            //print("pass");            isTrue = true;            //return true;        } else {            //print("fail");            isTrue = false;            //return false;       }    }    //print("is true? "+isTrue);    if (isTrue){ return true; } }// get symbol by nameMySymbol.prototype.getByName = function(nameString) {    for (i=0; i<idoc.symbolItems.length; i++) // loop thru all symbol items in the active document        {            var symbolitem = idoc.symbolItems[i]; // get each symbol item            if (symbolitem.symbol.name == nameString) { // check if it is an instance of "Apples" symbol                symbolitem.selected = true; // if it is, then select it            }     }} ////////////////////////////////////   export first s//   get symbol height/width//////////////////////////////////        //var firstSymbol = new mySymbol(1);        //var myHeight = mySymbol.height();        //var myWidth = mySymbol.width();        ////////////////////////////////////   TOSS THESE EVENTUALLY - JCI library//   or refactor them, they are gross DEWD, gross :)//////////////////////////////////function textIsIn(textChild, parentPageItem){    var textVB = textChild.visibleBounds,        textLeft = textVB[0],        textTop = Math.abs(textVB[1]),        textRight = textVB[2],        textBottom= Math.abs(textVB[3]);            var parentVB = parentPageItem.visibleBounds,        parentLeft = parentVB[0],        parentTop = Math.abs(parentVB[1]),        parentRight = parentVB[2],        parentBottom = Math.abs(parentVB[3]);            //$.write(textChild.contents+" :  [ left: "+left+", bottom: "+Math.abs(bottom)+"]  \n\n" );    //$.write(parentPageItem.name+" :   [ left: "+parentLeft+", top: "+parentTop+", right: "+parentRight+", bottom: "+parentBottom+"]  \n\n" );     //return true if child is in parent        return textLeft >= parentLeft &&  textRight <= parentRight &&            textBottom <= parentBottom  &&  textTop >= parentTop;}////////////////////// END FUNCTIONS  //////////////////////