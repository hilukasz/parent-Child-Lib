#target illustrator// @include lukaszLibrary.jsxfunction initMe(){    // objects and methodstefunction Parent(parentObject){    this.value = parentObject; // reference to single child container    this.name = parentObject.name;    this.symbolItems = []; //array of symbols    this.children = [];    this.childrenByName = [];    this.level = "";    this.visibleBounds = parentObject.visibleBounds;    this.left = this.visibleBounds[0];    this.top = this.visibleBounds[1];    this.right = this.visibleBounds[2];    this.bottom = this.visibleBounds[3];}function Child(theChild) {    this.value = theChild;      this.name = this.value.name.replace("[child] ", "");    this.parent = function() {        //find smallest parent        //potentialParentToCheckForChildren    }    this.relativePosition = function(){            };}/*Parent.prototype.getChildren = function() {   for (var i = 0; i < potentialParentToCheckForChildren.length; i++) {        //var visibleBounds = this.myLayerItem[i].visibleBounds;        // add new child object for every child        var children = this.children[i];        var child = new Child(children);        // populate children in Parent constructor        childCollection.push(child);        childCollection[i].parent = this.value;    }}*///start scriptvar potentialParentToCheckForChildren = app.activeDocument.layers.getByName("parent").pageItems,    parentCollection = [],    childCollection = [];function findSmallestParent(parent) {    // CHILD LOOP    for(var i = 0; i < subLayers.length; i++){        var smallestChild,            usedContainerIndexes = [],            childContainer = subLayers[i],            childContainerArea = childContainer.width * childContainer.height,            collectionOfParents = [],            myContainer = [];              print("#################"+childContainer.name+" : CHILD compare ###################");                // PARENT LOOP CHECK        for(var j = 0; j < subLayers.length; j++){            var parentContainer = subLayers[j],                parentArea = parentContainer.width * parentContainer.height;                            if (i != j){                print("-----"+parentContainer.name+" : PARENT compair -----");                                 // SET PARENT AND CHILD RELATIONSHIP VARIABLES                if(isIn(childContainer, parentContainer) &&  childContainerArea < parentArea && usedContainerIndexes.indexOf(j) === -1) {                    print(">> TEST :: "+childContainer.name+": SMALLEST CHILD // area:"+childContainerArea+" // "+smallestChild+" (index: "+j+") USED TO BE SMALLEST CHILD its parent is: "+parentContainer);                    myContainer.push(new Container(childContainer));                    smallestChild = childContainer;                    smallestChildrenCollection.push(childContainer);                    smallestParentArea = parentArea;                    usedContainerIndexes.push(j);                    usedChildContainerIndexes.push(i);                    parentSmallest.push(parentContainer);                    // push multiple instances of parent container to smallest container class                    collectionOfParents.push(parentContainer);                }            }           } // END : PARENT        //myContainer[i].parent.push(collectionOfParents);        //myContainer[i].value = smallestChild;        print("$$$$$$$$$$$$ SMALLEST CHILD FOR OBJECT: "+smallestChild);    } //END : CHILD    }//create a collection of Parent Objectsfunction setupParents(){    // POTENTIAL PARENT     for(var i = 0; i < potentialParentToCheckForChildren.length; i++){        var potentialParent = potentialParentToCheckForChildren[i];        var parent = new Parent(potentialParent);        // POTENTIAL CHILD        for(var j = 0; j < potentialParentToCheckForChildren.length; j++){            var potentialChild = potentialParentToCheckForChildren[j];            if (i != j && doesParentHaveChild(potentialChild , potentialParent)){ //don't check against itself                parent.children.push(potentialChild);                parent.childrenByName.push(potentialChild.name);            }        }        if(parent.children[0] != null){            parentCollection.push(parent);        }    }    return parentCollection;}setupParents();function setupChildren(){    // POTENTIAL PARENT     for(var i = 0; i < potentialParentToCheckForChildren.length; i++){        var potentialParent = potentialParentToCheckForChildren[i];        var parent = new Parent(potentialParent);        // POTENTIAL CHILD        for(var j = 0; j < potentialParentToCheckForChildren.length; j++){            var potentialChild = potentialParentToCheckForChildren[j];            if (i != j && doesParentHaveChild(potentialChild , potentialParent)){ //don't check against itself                parent.children.push(potentialChild);                parent.childrenByName.push(potentialChild.name);            }        }        if(parent.children[0] != null){            parentCollection.push(parent);        }    }    return parentCollection;}setupChildren();function doesChildHaveParent(child, parentItem){        var childVB = child.visibleBounds,            childLeft = childVB[0],        childTop = Math.abs(childVB[1]),        childRight = childVB[2],        childBottom = Math.abs(childVB[3]),                parentVB = parentItem.visibleBounds,                parentLeft = parentVB[0],        parentTop = Math.abs(parentVB[1]),        parentRight = parentVB[2],        parentBottom = Math.abs(parentVB[3]);            //$.write(child.name+" :  [ left: "+childVB[0]+" , top: "+Math.abs(childVB[1]) +" , right: "+childVB[2] +", bottom: "+Math.abs(childVB[3])+"]  \n\n" );    //$.write(parentItem.name+" :   [ left: "+parentVB[0]+", top: "+Math.abs(parentVB[1]) +" , right: "+parentVB[2] +" , bottom: "+Math.abs(parentVB[3])+"]  \n\n" );        //return true if child is in parent    return childLeft <= parentLeft &&            childTop <= parentTop &&            childRight >= parentRight &&            childBottom >= parentBottom;}parentCollection[0].getChildren();for(var j = 0; j < parentCollection.length; j++){    print(" ===== CHILDREN ======");    parentCollection[j].getChildren();    printObj(childCollection[j]);}for(var j = 0; j < parentCollection.length; j++){    print(" ===== PARENTS ======");    printObj(parentCollection[j]);}function doesParentHaveChild(child, parentItem){        var childVB = child.visibleBounds,        childLeft = childVB[0],        childTop = Math.abs(childVB[1]),        childRight = childVB[2],        childBottom = Math.abs(childVB[3]),        parentVB = parentItem.visibleBounds,        parentLeft = parentVB[0],        parentTop = Math.abs(parentVB[1]),        parentRight = parentVB[2],        parentBottom = Math.abs(parentVB[3]);            //$.write(child.name+" :  [ left: "+childVB[0]+" , top: "+Math.abs(childVB[1]) +" , right: "+childVB[2] +", bottom: "+Math.abs(childVB[3])+"]  \n\n" );    //$.write(parentItem.name+" :   [ left: "+parentVB[0]+", top: "+Math.abs(parentVB[1]) +" , right: "+parentVB[2] +" , bottom: "+Math.abs(parentVB[3])+"]  \n\n" );        //return true if child is in parent    return childLeft >= parentLeft &&            childTop >= parentTop &&            childRight <= parentRight &&            childBottom <= parentBottom;}//find smallest parent of page item//input subLayers, all page items here/*function theSmallestPageItemOf(parentToCheckForSmallest, parent){    var theSmallestPageItem = [];    for(var i = 0; i < parentToCheckForSmallest.length; i++){        var smallestParent;        var parent = parentToCheckForSmallest[i];        var parentArea = parentToCheckForSmallest[i].height*parentToCheckForSmallest[i].width;        for(var j = 0; j < parentToCheckForSmallest.length; j++){            if (i != j){                var child = parentToCheckForSmallest[j];                var childArea = parentToCheckForSmallest[j].height*parentToCheckForSmallest[j].width;                if(childArea < parentArea){                    smallestParent = child;                }            }        }    }    return theSmallestPageItem;}*/}initMe();parentCollection = null;